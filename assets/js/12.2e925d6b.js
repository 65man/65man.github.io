(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{367:function(t,v,_){"use strict";_.r(v);var a=_(45),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[t._v("#")]),t._v(" 前言")]),t._v(" "),_("p",[t._v("这里记录面试所遇到的 vue 的一些问题，知识在于积累，量变引起质变。")]),t._v(" "),_("h2",{attrs:{id:"_1-对mvvm的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-对mvvm的理解"}},[t._v("#")]),t._v(" 1. 对MVVM的理解")]),t._v(" "),_("p",[t._v("是Model-View-ViewModel,Model代表数据层，View代表视图层，ViewModel代表连接数据层和视图层的桥梁，视图层数据变动会通知数据层更改，数据层的数据变更也会通知视图层的更新。这样我们就数据层和视图层分离，我们就可以更专注于数据层的逻辑。")]),t._v(" "),_("h2",{attrs:{id:"_2-对vue的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-对vue的理解"}},[t._v("#")]),t._v(" 2. 对vue的理解")]),t._v(" "),_("h2",{attrs:{id:"_3-vue声明周期的理解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-vue声明周期的理解"}},[t._v("#")]),t._v(" 3. Vue声明周期的理解")]),t._v(" "),_("ul",[_("li",[t._v("创建前，创建后，挂载前，挂载后，更新前，更新后，销毁前，销毁后这八个声明周期。")]),t._v(" "),_("li",[t._v("一般我们在挂载后mounted这个声明周期发起数据请求，如果放在created里，请求过多，加载过会导致页面出现短暂的白屏。")])]),t._v(" "),_("h2",{attrs:{id:"_4-父子组件的生命周期"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-父子组件的生命周期"}},[t._v("#")]),t._v(" 4. 父子组件的生命周期")]),t._v(" "),_("ul",[_("li",[t._v("渲染阶段：父组件先子组件后，然后子组件先渲染完成，在是父组件")]),t._v(" "),_("li",[t._v("更新阶段：父先子后，更新完事子先父后")]),t._v(" "),_("li",[t._v("销毁阶段：父先子后，销毁完是子先父后")])]),t._v(" "),_("h2",{attrs:{id:"_5-生命周期函数是如何实现的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-生命周期函数是如何实现的"}},[t._v("#")]),t._v(" 5. 生命周期函数是如何实现的")]),t._v(" "),_("h2",{attrs:{id:"_6-vue的单向数据流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-vue的单向数据流"}},[t._v("#")]),t._v(" 6. vue的单向数据流")]),t._v(" "),_("p",[t._v("单向数据流只指组件之前的数据传递，父组件向子组件传递数据，但是子组件不能直接修改props传递过来的数据，子组件只能同过$emit来通知父组件更新数据。这样所有的数据都只有一份，就是父组件的data。")]),t._v(" "),_("p",[t._v("如果父组件里有多个子组件，子组件能修改父组件传递的props,那么就有造成数据的混乱，难以理解。")]),t._v(" "),_("h2",{attrs:{id:"_7-vue组件的通信"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue组件的通信"}},[t._v("#")]),t._v(" 7. Vue组件的通信")]),t._v(" "),_("ul",[_("li",[t._v("父传子 props 子传父$emit")]),t._v(" "),_("li",[t._v("eventBus")]),t._v(" "),_("li",[t._v("vuex")]),t._v(" "),_("li",[t._v("provide/inject:祖先元素向后代注入依赖")])]),t._v(" "),_("h2",{attrs:{id:"_8-computed和watch的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-computed和watch的区别"}},[t._v("#")]),t._v(" 8. computed和watch的区别")]),t._v(" "),_("p",[t._v("计算属性：")]),t._v(" "),_("ol",[_("li",[t._v("支持缓存，只有依赖的数据发生改变时，才会重新计算")]),t._v(" "),_("li",[t._v("计算属性内不支持异步操作")]),t._v(" "),_("li",[t._v("计算属性内都要一个get和set的方法")]),t._v(" "),_("li",[t._v("计算属性是自动监听依赖值的改变，从而动态返回")])]),t._v(" "),_("p",[t._v("watch:")]),t._v(" "),_("ol",[_("li",[t._v("不支持缓存，只要有数据变化，就执行侦听函数")]),t._v(" "),_("li",[t._v("watch支持异步操作")]),t._v(" "),_("li",[t._v("watch的值可以是一个对象，侦听属性的值可以是一个对象，接受handler回调，deep,immediate三个属性")]),t._v(" "),_("li",[t._v("监听是一个过程，监听的值变化时，可以出发一个回调。")])]),t._v(" "),_("h2",{attrs:{id:"_9-vue如何实现双向绑定-响应式数据原理-重点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-vue如何实现双向绑定-响应式数据原理-重点"}},[t._v("#")]),t._v(" 9. Vue如何实现双向绑定（响应式数据原理）重点")]),t._v(" "),_("h2",{attrs:{id:"_10-vue如何检测数组变化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue如何检测数组变化"}},[t._v("#")]),t._v(" 10. Vue如何检测数组变化")]),t._v(" "),_("h2",{attrs:{id:"_11-vue中模板编译原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-vue中模板编译原理"}},[t._v("#")]),t._v(" 11. Vue中模板编译原理")])])}),[],!1,null,null,null);v.default=e.exports}}]);